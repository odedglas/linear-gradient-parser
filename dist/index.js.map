{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utils/colors/hexToRgb/index.js","webpack:///./src/utils/colors/formatRgb/index.js","webpack:///./src/utils/colors/parseRgb/index.js","webpack:///./src/utils/colors/getStopColor/index.js","webpack:///./src/utils/defined/index.js","webpack:///./src/utils/calmpAngle/index.js","webpack:///./src/utils/getGradientAngle/index.js","webpack:///./src/utils/getGradientStops/index.js","webpack:///./src/utils/getAngleCords/index.js","webpack:///./src/constnats.js","webpack:///./src/utils/getAngleCords/constants.js","webpack:///./src/utils/getStopOffset/index.js","webpack:///./src/utils/parseLinearGradient/index.js","webpack:///./src/index.js","webpack:///./index.js"],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","m","formatHexNumber","item","parseInt","repeat","length","hexToRgb","hex","opacity","result","hexRegExp","exec","sortHexRegExp","r","g","b","undefined","RegExp","formatRgb","formatNumber","num","Number","rgbRegExp","colorClassifiers","regexps","handler","rgbString","match","join","every","isValidRgb","getStopColor","color","classifier","find","some","regexp","test","Error","parsedColor","defined","value","clampAngle","angle","formatPosition","pos","trim","endsWith","replace","getColor","stop","attributeColor","getAttribute","ATTRIBUTES","styleString","el","document","createElement","setAttribute","style","getStyles","styleColor","styleOpacity","formatPoint","Math","abs","EPSILON","anglePoint","x","cos","y","sin","degreesToRadians","degrees","PI","getGradientAngle","x1","x2","y1","y2","map","angleRad","atan2","POSITION_ATTRIBUTES","getGradientStops","lg","Array","from","querySelectorAll","offset","getStopOffset","pow","getAngleCords","adjustedAngle","startPoint","CIRCLE_DEGREES","endPoint","toString","parser","DOMParser","parserHandlers","string","linearGradientString","parseFromString","querySelector","reduce","attributes","attr","Object","assign","positionAttributes","stops","filter","object","gradient","getBackground","linearGradient","handleType","children","background","asBackground","getGradientCords","c","d","name","getter","o","defineProperty","enumerable","get","Symbol","toStringTag","t","mode","__esModule","ns","create","key","bind","n","property","prototype","hasOwnProperty","call","p","s","moduleId","l","modules"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const hexRegExp = new RegExp(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\nexport const sortHexRegExp = new RegExp(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i);\n\nconst formatHexNumber = (item) => parseInt(\n    item.repeat(3 - item.length),\n    16\n);\n\n/**\n * Converts a hex color string into rgb\n * @param {String} hex - Hex color string\n * @param {Number} opacity - The opacity to use\n * @returns {Object}\n */\nconst hexToRgb = (hex, opacity = 1) => {\n    const result = hexRegExp.exec(hex) || sortHexRegExp.exec(hex);\n\n    return result ? {\n        r: formatHexNumber(result[1]),\n        g: formatHexNumber(result[2]),\n        b: formatHexNumber(result[3]),\n        a: opacity\n    } : undefined;\n};\n\nexport default hexToRgb;\n","/**\n * Formats an rgba into a css rgb/a property\n * @returns {String}\n */\nconst formatRgb = ({ r, g, b, a = 1}) => a !== 1 ? `rgba(${r}, ${g}, ${b}, ${a})`\n    : `rgb(${r}, ${g}, ${b})`;\n\nexport default formatRgb;\n","export const rgbRegExp = new RegExp(/\\d+/g);\n\nconst formatNumber = (num) => Number(num);\n\nconst isValidRgb = (r, g, b, a) => {\n  return [r, g ,b].every((i) => i >= 0 && i <= 255) && (!a || (a >= 0 && a <= 1));\n};\n\n/**\n * Parses a rba / rgba string, ensure it's validness\n * @param {String} rgbString\n * @returns {Object}\n */\nconst parseRgb = (rgbString) => {\n    const [r, g, b, ...a] = rgbString.match(rgbRegExp);\n    const opacity = a.join('.') || 1;\n\n    return isValidRgb(r, g, b, opacity) ? {\n        r: formatNumber(r),\n        g: formatNumber(g),\n        b: formatNumber(b),\n        a: formatNumber(opacity)\n    } : undefined;\n};\n\nexport default parseRgb;\n","import formatRgb from '../formatRgb';\nimport parseRgb, { rgbRegExp } from '../parseRgb';\nimport hexToRgb, { hexRegExp, sortHexRegExp } from '../hexToRgb';\n\nconst colorClassifiers = [\n    { regexps: [hexRegExp, sortHexRegExp], handler: hexToRgb },\n    { regexps: [rgbRegExp], handler: parseRgb }\n];\n\nconst getStopColor = (color, opacity) => {\n    const classifier = colorClassifiers.find(({ regexps }) =>\n        regexps.some((regexp) => regexp.test(color))\n    );\n\n    if (!classifier) {\n        throw new Error(`Stop color - ${color} does not follow one of the accepted formats Hex / Rgb / Rgba `);\n    }\n\n    const parsedColor = classifier.handler(color, opacity);\n\n    return formatRgb(parsedColor);\n};\n\nexport default getStopColor;\n","/**\n * Determines if undefined or null\n * @param {?} value - The value to check\n * @returns {Boolean}\n */\nconst defined = (value) => {\n    return value !== undefined && value !== null;\n};\n\nexport default defined;\n","/**\n * Clamps an angle into given boundaries\n * @param {Number} angle\n * @param {Number} min\n * @param {Number} max\n * @returns {Number}\n */\nconst clampAngle = (angle, min = 0, max = 360) => {\n    if (angle < min) {\n        return 360 + angle;\n    }\n\n    if (angle > max) {\n        return angle - 360;\n    }\n\n    return angle;\n};\n\nexport default clampAngle;\n","import clampAngle from '../calmpAngle';\n\n/**\n * Formats a given position attribute\n * @param {String} pos - the position value\n * @returns {Number}\n */\nconst formatPosition = (pos) => Number(`${pos}`.trim().endsWith('%') ?\n    pos.trim().replace('%', '') : pos);\n\n/**\n * Returns a gradient angle by a given position properties\n * @param {String} x1 - The gradient x1 position\n * @param {String} x2 - The gradient x2 position\n * @param {String} y1 - The gradient y1 position\n * @param {String} y2 - The gradient y2 position\n * @returns {Number}\n */\nconst getGradientAngle = ({ x1, x2, y1, y2 }) => {\n\n    [x1, x2, y1, y2] = [x1, x2, y1, y2].map(formatPosition);\n\n    const x = x2 - x1;\n    const y = y2 - y1;\n\n    // Single axis\n    if (y === 0) {\n        return x1 > x2 ? 270 : 90;\n    }\n\n    if (x === 0) {\n        return y1 > y2 ? 0 : 180;\n    }\n\n    // Converts angle in degrees\n    const angleRad = Math.atan2(y, x);\n    return clampAngle((angleRad * 180 / Math.PI) + 90);\n};\n\nexport default getGradientAngle;\n","import { getStopOffset, getStopColor } from '..';\nimport { ATTRIBUTES } from '../../constnats';\n\n/**\n * Returns a CSSStyleDeclaration from a astring\n * @param {String} styleString\n * @returns {CSSStyleDeclaration}\n */\nconst getStyles = (styleString) => {\n    const el = document.createElement('div');\n\n    el.setAttribute('style', styleString);\n\n    return el.style;\n};\n\n/**\n * Returns a given stop html element it's color\n * @param {HTMLElement} stop\n * @returns {String} rgb / rgba formatted color\n */\nconst getColor = (stop) => {\n    const attributeColor = stop.getAttribute(ATTRIBUTES.STOP_COLOR);\n    if (attributeColor) {\n        const opacity = stop.getAttribute(ATTRIBUTES.STOP_OPACITY);\n\n        return getStopColor(attributeColor, opacity);\n    }\n\n    const {\n        [ATTRIBUTES.STOP_COLOR]: styleColor,\n        [ATTRIBUTES.STOP_OPACITY]: styleOpacity\n    } = getStyles(stop.getAttribute(ATTRIBUTES.STYLE));\n\n    return styleColor ? getStopColor(styleColor, styleOpacity) : undefined;\n};\n\n/**\n * Parses a Linear gradient HTML element into Stop\n * @param {HTMLElement} lg - The linear gradient\n * @returns {Stop[]}\n */\nconst getGradientStops = (lg) => Array.from(lg.querySelectorAll('stop'))\n    .map((stop) => {\n\n    const offset = getStopOffset(stop.getAttribute(ATTRIBUTES.OFFSET));\n    const color = getColor(stop);\n\n    return { offset: Number(offset), color };\n});\n\nexport default getGradientStops;\n","import {\n    CIRCLE_DEGREES,\n    START_POINT_RATIO,\n    END_POINT_RATIO,\n    EPSILON\n} from './constants';\n\n/**\n * Formats a cord point, ensure it's value\n * @param {Number} value\n * @returns {Number}\n */\nconst formatPoint = (value) => (value <= 0 || (Math.abs(value) <= EPSILON)) ? 0 : value;\n\n/**\n * Calculates a angle point by sin / cos\n * @param {Number} angle\n * @returns {{x: Number, y: Number}}\n */\nconst anglePoint = (angle) => ({\n    x: formatPoint(Math.cos(angle)),\n    y: formatPoint(Math.sin(angle))\n});\n\n/**\n * Turns a given degree into radians\n * @param {Number} degrees\n * @returns {Number}\n */\nconst degreesToRadians = (degrees) => ((degrees * Math.PI) / 180);\n\n/**\n * Returns a start / end coordinates of a given angle\n * @param {Number} angle\n * @returns {{startPoint: {x: Number, y: Number}, endPoint: {x: Number, y: Number}}}\n */\nconst getAngleCords = (angle = 0) => {\n    const adjustedAngle = ((CIRCLE_DEGREES - angle) % CIRCLE_DEGREES);\n\n    const startPoint = anglePoint(degreesToRadians(START_POINT_RATIO - adjustedAngle));\n    const endPoint = anglePoint(degreesToRadians(END_POINT_RATIO - adjustedAngle));\n\n    return { startPoint, endPoint };\n};\n\nexport default getAngleCords;\n","/**\n * HTML attributes mapping\n */\nexport const ATTRIBUTES = {\n    X1: 'x1',\n    X2: 'x2',\n    Y1: 'y1',\n    Y2: 'y2',\n    STYLE: 'style',\n    STOP_COLOR: 'stop-color',\n    STOP_OPACITY: 'stop-opacity',\n    OFFSET: 'offset'\n};\n/**\n * Linear gradient position attributes\n * @type {String[]}\n */\nexport const POSITION_ATTRIBUTES = [\n    ATTRIBUTES.X1,\n    ATTRIBUTES.X2,\n    ATTRIBUTES.Y1,\n    ATTRIBUTES.Y2\n];\n","/**\n * The amount of degrees in circle\n * @type {Number}\n */\nexport const CIRCLE_DEGREES = 360;\n\n/**\n * The gradient angle start point ratio\n * @type {Number}\n */\nexport const START_POINT_RATIO = CIRCLE_DEGREES / 4;\n\n/**\n * The gradient angle end point ratio\n * @type {Number}\n */\nexport const END_POINT_RATIO = CIRCLE_DEGREES * (3 / 4);\n\n/**\n * The epsilon representation\n * @type {Number}\n */\nexport const EPSILON = Math.pow(2, -52);\n","/**\n * Returns an offset\n * @param {String} offset - Stop offset, Can contain %\n * @returns {Number}\n */\nconst getStopOffset = (offset) => {\n    offset = offset.toString().trim();\n\n    if (offset.endsWith('%')) {\n        return Number(offset.replace('%', ''));\n    }\n\n    // Assume 0-1 as percentage when offset has no %\n    return Number(offset) * 100;\n};\n\nexport default getStopOffset;\n","import { defined, getGradientStops } from '..';\nimport { POSITION_ATTRIBUTES } from '../../constnats';\n\nconst parser = new DOMParser();\n\n/**\n * Returns linear gradient position effecting properties\n * @param {HTMLElement} lg - The linear gradient element to parse\n * @returns {Object}\n */\nconst positionAttributes = (lg) => POSITION_ATTRIBUTES.reduce(\n    (attributes, attr) => Object.assign(attributes, { [attr]: lg.getAttribute(attr) })\n    , {});\n\n/**\n * Parses an HTML linear gradient element into json rep\n * @param linearGradientString\n * @returns {LinearGradient}\n */\nconst parseLinearGradient = (linearGradientString) => {\n    const doc = parser.parseFromString(linearGradientString, 'image/svg+xml');\n    const lg = doc.querySelector('linearGradient');\n\n    if (!lg) {\n        throw new Error('Couldn\\'t parse svg string into linearGradient SVGElement');\n    }\n\n    return {\n        ...positionAttributes(lg),\n        stops: getGradientStops(lg).filter(({ offset, color }) =>\n            defined(offset) && defined(color)\n        )\n    };\n};\n\nexport default parseLinearGradient;\n","import {\n    parseLinearGradient,\n    getGradientAngle,\n    getStopColor,\n    getStopOffset,\n    getAngleCords\n} from './utils';\n\n/**\n * Formats into linear gradient background property\n * @param {Number} angle - The linear gradient degree\n * @param {Stop[]} stops - The linear gradient stops\n * @returns {String}\n */\nconst asBackground = ({ angle, stops }) => stops.length === 1 ? stops[0].color : `linear-gradient(${angle}deg, ${\n    stops\n    .map(stop => `${stop.color} ${stop.offset}%`)\n    .join(', ')\n})`;\n\nconst parserHandlers = {\n    string: parseLinearGradient,\n    object: (gradient) => ({\n        ...gradient,\n        stops: gradient.stops.map(({ offset, color, opacity }) => ({\n            offset: getStopOffset(offset),\n            color: getStopColor(color, opacity)\n        }))\n    })\n};\n\nexport default {\n\n    /**\n     * Transform a given linear gradient ( String or json ) into css background image property\n     * @param {String|LinearGradient} linearGradient - The linear gradient\n     * @returns BackgroundResult\n     */\n    getBackground(linearGradient) {\n        const handleType = typeof linearGradient;\n        const handler = parserHandlers[handleType];\n\n        if (!handler) {\n            throw new Error('Cannot parse non JSON / SVG String input');\n        }\n\n        linearGradient = handler(linearGradient);\n\n        const stops = linearGradient.stops || linearGradient.children;\n        const angle = getGradientAngle(linearGradient);\n\n        const background = asBackground({ angle, stops });\n\n        return { angle, background };\n    },\n\n    getGradientCords(angle) {\n        const { startPoint, endPoint } = getAngleCords(angle);\n\n        return {\n            x1: startPoint.x,\n            y1: startPoint.y,\n            x2: endPoint.x,\n            y2: endPoint.y\n        };\n    }\n};\n","import parser from './src';\n\nexport default parser;\n"],"sourceRoot":""}