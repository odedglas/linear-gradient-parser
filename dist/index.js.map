{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utils/colors/hexToRgb/index.js","webpack:///./src/utils/colors/formatRgb/index.js","webpack:///./src/utils/colors/parseRgb/index.js","webpack:///./src/utils/colors/getStopColor/index.js","webpack:///./src/utils/defined/index.js","webpack:///./src/utils/calmpAngle/index.js","webpack:///./src/utils/getGradientAngle/index.js","webpack:///./src/utils/getGradientStops/index.js","webpack:///./src/utils/getAngleCords/index.js","webpack:///./src/utils/parseLinearGradient/index.js","webpack:///./src/constnats.js","webpack:///./src/utils/getAngleCords/constants.js","webpack:///./src/utils/getStopOffset/index.js","webpack:///./src/index.js","webpack:///./index.js"],"names":["root","factory","exports","module","define","amd","i","a","self","this","installedModules","__webpack_require__","m","formatHexNumber","item","parseInt","repeat","length","hexRegExp","RegExp","sortHexRegExp","hexToRgb","hex","opacity","result","exec","r","g","b","undefined","formatRgb","formatNumber","num","Number","rgbRegExp","colorClassifiers","regexps","handler","rgbString","match","join","every","getStopColor","color","classifier","find","some","regexp","test","Error","parsedColor","defined","value","clampAngle","angle","formatPosition","pos","trim","endsWith","replace","getColor","stop","attributeColor","getAttribute","ATTRIBUTES","styleString","el","document","createElement","setAttribute","style","styleColor","styleOpacity","formatPoint","Math","abs","EPSILON","anglePoint","x","cos","y","sin","degreesToRadians","degrees","PI","parser","getGradientAngle","x1","x2","y1","y2","map","angleRad","atan2","POSITION_ATTRIBUTES","getGradientStops","lg","Array","from","querySelectorAll","offset","getStopOffset","pow","getAngleCords","adjustedAngle","startPoint","CIRCLE_DEGREES","endPoint","toString","parserHandlers","string","linearGradientString","DOMParser","parseFromString","querySelector","reduce","attributes","attr","Object","assign","stops","filter","object","gradient","getBackground","linearGradient","handleType","children","background","getGradientCords","c","d","name","getter","o","defineProperty","enumerable","get","Symbol","toStringTag","t","mode","__esModule","ns","create","key","bind","n","property","prototype","hasOwnProperty","call","p","s","moduleId","l","modules"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const hexRegExp = new RegExp(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\nexport const sortHexRegExp = new RegExp(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i);\n\nconst formatHexNumber = (item) => parseInt(\n    item.repeat(3 - item.length),\n    16\n);\n\n/**\n * Converts a hex color string into rgb\n * @param {String} hex - Hex color string\n * @param {Number} opacity - The opacity to use\n * @returns {Object}\n */\nconst hexToRgb = (hex, opacity = 1) => {\n    const result = hexRegExp.exec(hex) || sortHexRegExp.exec(hex);\n\n    return result ? {\n        r: formatHexNumber(result[1]),\n        g: formatHexNumber(result[2]),\n        b: formatHexNumber(result[3]),\n        a: opacity\n    } : undefined;\n};\n\nexport default hexToRgb;\n","/**\n * Formats an rgba into a css rgb/a property\n * @returns {String}\n */\nconst formatRgb = ({ r, g, b, a = 1}) => a !== 1 ? `rgba(${r}, ${g}, ${b}, ${a})`\n    : `rgb(${r}, ${g}, ${b})`;\n\nexport default formatRgb;\n","export const rgbRegExp = new RegExp(/\\d+/g);\n\nconst formatNumber = (num) => Number(num);\n\nconst isValidRgb = (r, g, b, a) => {\n  return [r, g ,b].every((i) => i >= 0 && i <= 255) && (!a || (a >= 0 && a <= 1));\n};\n\n/**\n * Parses a rba / rgba string, ensure it's validness\n * @param {String} rgbString\n * @returns {Object}\n */\nconst parseRgb = (rgbString) => {\n    const [r, g, b, ...a] = rgbString.match(rgbRegExp);\n    const opacity = a.join('.') || 1;\n\n    return isValidRgb(r, g, b, opacity) ? {\n        r: formatNumber(r),\n        g: formatNumber(g),\n        b: formatNumber(b),\n        a: formatNumber(opacity)\n    } : undefined;\n};\n\nexport default parseRgb;\n","import formatRgb from '../formatRgb';\nimport parseRgb, { rgbRegExp } from '../parseRgb';\nimport hexToRgb, { hexRegExp, sortHexRegExp } from '../hexToRgb';\n\nconst colorClassifiers = [\n    { regexps: [hexRegExp, sortHexRegExp], handler: hexToRgb },\n    { regexps: [rgbRegExp], handler: parseRgb }\n];\n\nconst getStopColor = (color, opacity) => {\n    const classifier = colorClassifiers.find(({ regexps }) =>\n        regexps.some((regexp) => regexp.test(color))\n    );\n\n    if (!classifier) {\n        throw new Error(`Stop color - ${color} does not follow one of the accepted formats Hex / Rgb / Rgba `);\n    }\n\n    const parsedColor = classifier.handler(color, opacity);\n\n    return formatRgb(parsedColor);\n};\n\nexport default getStopColor;\n","/**\n * Determines if undefined or null\n * @param {?} value - The value to check\n * @returns {Boolean}\n */\nconst defined = (value) => {\n    return value !== undefined && value !== null;\n};\n\nexport default defined;\n","/**\n * Clamps an angle into given boundaries\n * @param {Number} angle\n * @param {Number} min\n * @param {Number} max\n * @returns {Number}\n */\nconst clampAngle = (angle, min = 0, max = 360) => {\n    if (angle < min) {\n        return 360 + angle;\n    }\n\n    if (angle > max) {\n        return angle - 360;\n    }\n\n    return angle;\n};\n\nexport default clampAngle;\n","import clampAngle from '../calmpAngle';\n\n/**\n * Formats a given position attribute\n * @param {String} pos - the position value\n * @returns {Number}\n */\nconst formatPosition = (pos) => Number(`${pos}`.trim().endsWith('%') ?\n    pos.trim().replace('%', '') : pos);\n\n/**\n * Returns a gradient angle by a given position properties\n * @param {String} x1 - The gradient x1 position\n * @param {String} x2 - The gradient x2 position\n * @param {String} y1 - The gradient y1 position\n * @param {String} y2 - The gradient y2 position\n * @returns {Number}\n */\nconst getGradientAngle = ({ x1, x2, y1, y2 }) => {\n\n    [x1, x2, y1, y2] = [x1, x2, y1, y2].map(formatPosition);\n\n    const x = x2 - x1;\n    const y = y2 - y1;\n\n    // Single axis\n    if (y === 0) {\n        return x1 > x2 ? 270 : 90;\n    }\n\n    if (x === 0) {\n        return y1 > y2 ? 0 : 180;\n    }\n\n    // Converts angle in degrees\n    const angleRad = Math.atan2(y, x);\n    return clampAngle((angleRad * 180 / Math.PI) + 90);\n};\n\nexport default getGradientAngle;\n","import { getStopOffset, getStopColor } from '..';\nimport { ATTRIBUTES } from '../../constnats';\n\n/**\n * Returns a CSSStyleDeclaration from a astring\n * @param {String} styleString\n * @returns {CSSStyleDeclaration}\n */\nconst getStyles = (styleString) => {\n    const el = document.createElement('div');\n\n    el.setAttribute('style', styleString);\n\n    return el.style;\n};\n\n/**\n * Returns a given stop html element it's color\n * @param {HTMLElement} stop\n * @returns {String} rgb / rgba formatted color\n */\nconst getColor = (stop) => {\n    const attributeColor = stop.getAttribute(ATTRIBUTES.STOP_COLOR);\n    if (attributeColor) {\n        const opacity = stop.getAttribute(ATTRIBUTES.STOP_OPACITY);\n\n        return getStopColor(attributeColor, opacity);\n    }\n\n    const {\n        [ATTRIBUTES.STOP_COLOR]: styleColor,\n        [ATTRIBUTES.STOP_OPACITY]: styleOpacity\n    } = getStyles(stop.getAttribute(ATTRIBUTES.STYLE));\n\n    return styleColor ? getStopColor(styleColor, styleOpacity) : undefined;\n};\n\n/**\n * Parses a Linear gradient HTML element into Stop\n * @param {HTMLElement} lg - The linear gradient\n * @returns {Stop[]}\n */\nconst getGradientStops = (lg) => Array.from(lg.querySelectorAll('stop'))\n    .map((stop) => {\n\n    const offset = getStopOffset(stop.getAttribute(ATTRIBUTES.OFFSET));\n    const color = getColor(stop);\n\n    return { offset: Number(offset), color };\n});\n\nexport default getGradientStops;\n","import {\n    CIRCLE_DEGREES,\n    START_POINT_RATIO,\n    END_POINT_RATIO,\n    EPSILON\n} from './constants';\n\n/**\n * Formats a cord point, ensure it's value\n * @param {Number} value\n * @returns {Number}\n */\nconst formatPoint = (value) => (value <= 0 || (Math.abs(value) <= EPSILON)) ? 0 : value;\n\n/**\n * Calculates a angle point by sin / cos\n * @param {Number} angle\n * @returns {{x: Number, y: Number}}\n */\nconst anglePoint = (angle) => ({\n    x: formatPoint(Math.cos(angle)),\n    y: formatPoint(Math.sin(angle))\n});\n\n/**\n * Turns a given degree into radians\n * @param {Number} degrees\n * @returns {Number}\n */\nconst degreesToRadians = (degrees) => ((degrees * Math.PI) / 180);\n\n/**\n * Returns a start / end coordinates of a given angle\n * @param {Number} angle\n * @returns {{startPoint: {x: Number, y: Number}, endPoint: {x: Number, y: Number}}}\n */\nconst getAngleCords = (angle = 0) => {\n    const adjustedAngle = ((CIRCLE_DEGREES - angle) % CIRCLE_DEGREES);\n\n    const startPoint = anglePoint(degreesToRadians(START_POINT_RATIO - adjustedAngle));\n    const endPoint = anglePoint(degreesToRadians(END_POINT_RATIO - adjustedAngle));\n\n    return { startPoint, endPoint };\n};\n\nexport default getAngleCords;\n","import { defined, getGradientStops } from '..';\nimport { POSITION_ATTRIBUTES } from '../../constnats';\n\nlet parser;\n\n/**\n * Returns linear gradient position effecting properties\n * @param {HTMLElement} lg - The linear gradient element to parse\n * @returns {Object}\n */\nconst positionAttributes = (lg) => POSITION_ATTRIBUTES.reduce(\n    (attributes, attr) => Object.assign(attributes, { [attr]: lg.getAttribute(attr) })\n    , {});\n\n/**\n * Parses an HTML linear gradient element into json rep\n * @param linearGradientString\n * @returns {LinearGradient}\n */\nconst parseLinearGradient = (linearGradientString) => {\n    parser = parser || new DOMParser();\n    const doc = parser.parseFromString(linearGradientString, 'image/svg+xml');\n    const lg = doc.querySelector('linearGradient');\n\n    if (!lg) {\n        throw new Error('Couldn\\'t parse svg string into linearGradient SVGElement');\n    }\n\n    return {\n        ...positionAttributes(lg),\n        stops: getGradientStops(lg).filter(({ offset, color }) =>\n            defined(offset) && defined(color)\n        )\n    };\n};\n\nexport default parseLinearGradient;\n","/**\n * HTML attributes mapping\n */\nexport const ATTRIBUTES = {\n    X1: 'x1',\n    X2: 'x2',\n    Y1: 'y1',\n    Y2: 'y2',\n    STYLE: 'style',\n    STOP_COLOR: 'stop-color',\n    STOP_OPACITY: 'stop-opacity',\n    OFFSET: 'offset'\n};\n/**\n * Linear gradient position attributes\n * @type {String[]}\n */\nexport const POSITION_ATTRIBUTES = [\n    ATTRIBUTES.X1,\n    ATTRIBUTES.X2,\n    ATTRIBUTES.Y1,\n    ATTRIBUTES.Y2\n];\n","/**\n * The amount of degrees in circle\n * @type {Number}\n */\nexport const CIRCLE_DEGREES = 360;\n\n/**\n * The gradient angle start point ratio\n * @type {Number}\n */\nexport const START_POINT_RATIO = CIRCLE_DEGREES / 4;\n\n/**\n * The gradient angle end point ratio\n * @type {Number}\n */\nexport const END_POINT_RATIO = CIRCLE_DEGREES * (3 / 4);\n\n/**\n * The epsilon representation\n * @type {Number}\n */\nexport const EPSILON = Math.pow(2, -52);\n","/**\n * Returns an offset\n * @param {String} offset - Stop offset, Can contain %\n * @returns {Number}\n */\nconst getStopOffset = (offset) => {\n    offset = offset.toString().trim();\n\n    if (offset.endsWith('%')) {\n        return Number(offset.replace('%', ''));\n    }\n\n    // Assume 0-1 as percentage when offset has no %\n    return Number(offset) * 100;\n};\n\nexport default getStopOffset;\n","import {\n    parseLinearGradient,\n    getGradientAngle,\n    getStopColor,\n    getStopOffset,\n    getAngleCords\n} from './utils';\n\n/**\n * Formats into linear gradient background property\n * @param {Number} angle - The linear gradient degree\n * @param {Stop[]} stops - The linear gradient stops\n * @returns {String}\n */\nconst asBackground = ({ angle, stops }) => stops.length === 1 ? stops[0].color : `linear-gradient(${angle}deg, ${\n    stops\n    .map(stop => `${stop.color} ${stop.offset}%`)\n    .join(', ')\n})`;\n\nconst parserHandlers = {\n    string: parseLinearGradient,\n    object: (gradient) => ({\n        ...gradient,\n        stops: gradient.stops.map(({ offset, color, opacity }) => ({\n            offset: getStopOffset(offset),\n            color: getStopColor(color, opacity)\n        }))\n    })\n};\n\nexport default {\n\n    /**\n     * Transform a given linear gradient ( String or json ) into css background image property\n     * @param {String|LinearGradient} linearGradient - The linear gradient\n     * @returns BackgroundResult\n     */\n    getBackground(linearGradient) {\n        const handleType = typeof linearGradient;\n        const handler = parserHandlers[handleType];\n\n        if (!handler) {\n            throw new Error('Cannot parse non JSON / SVG String input');\n        }\n\n        linearGradient = handler(linearGradient);\n\n        const stops = linearGradient.stops || linearGradient.children;\n        const angle = getGradientAngle(linearGradient);\n\n        const background = asBackground({ angle, stops });\n\n        return { angle, background };\n    },\n\n    getGradientCords(angle) {\n        const { startPoint, endPoint } = getAngleCords(angle);\n\n        return {\n            x1: startPoint.x,\n            y1: startPoint.y,\n            x2: endPoint.x,\n            y2: endPoint.y\n        };\n    }\n};\n","import parser from './src';\n\nexport default parser;\n"],"sourceRoot":""}